/*
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package ip_allow_test

import (
	"fmt"
	"testing"

	"github.com/apache/trafficcontrol/traffic_ops/testing/api/v1/config"
	"github.com/apache/trafficcontrol/traffic_ops/testing/api/v1/config/ip_allow"
)

var negativeTests = []config.NegativeTest{
	{
		"too few assignments",
		"foo1=foo",
		config.NotEnoughAssignments,
	},
	{
		"empty assignment",
		"src_ip= foo1=foo",
		config.BadAssignmentMatch,
	},
	{
		"missing equals in assignment",
		"src_ip foo1=foo",
		config.BadAssignmentMatch,
	},
	{
		"missing src_ip label",
		"action=ip_allow method=ALL",
		config.MissingLabel,
	},
	{
		"missing action label",
		"src_ip=0/0 method=ALL",
		config.MissingLabel,
	},
	{
		"unknown field",
		"foo1=foo foo2=foo foo3=foo",
		config.InvalidLabel,
	},
	{
		"extra action",
		"src_ip=0/0 action=ip_allow action=ip_deny",
		config.ExcessLabel,
	},
	{
		"extra ip",
		"src_ip=0/0 dest_ip=0.0.0.0 action=ip_allow",
		config.ExcessLabel,
	},
	{
		"invalid label on second line",
		fmt.Sprintf("%s\n\n%s",
			"src_ip=0/0 action=ip_allow",
			"foo1=foo foo2=foo foo3=foo"),
		config.InvalidLabel,
	},
	{
		"bad src_ip",
		"src_ip=x action=ip_allow",
		config.InvalidIPRange,
	},
	{
		"bad action",
		"src_ip=0/0 action=ip_allowed",
		config.InvalidAction,
	},
	{
		"unknown method",
		"src_ip=0/0 action=ip_allow method=x",
		config.UnknownMethod,
	},
	{
		"bad method delimiter",
		"src_ip=0/0 action=ip_allow method=GET|",
		config.UnknownMethod,
	},
	{
		"bad method delimiter",
		"src_ip=0/0 action=ip_allow method=GET,",
		config.UnknownMethod,
	},
	{
		"bad ip",
		"dest_ip=bad_ip foo1=foo",
		config.InvalidIPRange,
	},
}

var positiveTests = []config.PositiveTest{
	{
		"IPv4",
		"src_ip=127.0.0.1 action=ip_allow method=ALL",
	},
	{
		"IPv6 shorthand",
		"src_ip=::1 action=ip_allow method=ALL",
	},
	{
		"IPv4 dash range",
		"src_ip=0.0.0.0-255.255.255.255 action=ip_allow",
	},
	{
		"Multiple methods",
		"src_ip=0.0.0.0-255.255.255.255 action=ip_deny method=PUSH|PURGE|DELETE",
	},
	{
		"Multiple methods",
		"src_ip=0.0.0.0-255.255.255.255 action=ip_deny method=PUSH method=PURGE method=DELETE",
	},
	{
		"IPv6 dash range",
		"src_ip=::-ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff action=ip_deny method=PUSH|PURGE|DELETE",
	},
	{
		"IPv4 CIDR",
		"src_ip=123.45.6.0/24 action=ip_deny",
	},
	{
		"IPv4 CIDR (shorthand)",
		"src_ip=0/0 action=ip_deny method=PUSH|PURGE|DELETE",
	},
	{
		"IPv6 CIDR",
		"src_ip=::/0 action=ip_deny method=PUSH|PURGE|DELETE",
	},
	{
		"normal config returned from traffic ops",
		fmt.Sprintf("%s\n%s\n%s\n%s\n%s\n",
			"# DO NOT EDIT - Generated by Traffic Ops on Fri Mar 1 18:30:48 UTC 2019",
			"src_ip=127.0.0.1 action=ip_allow method=ALL",
			"src_ip=::1 action=ip_allow method=ALL",
			"src_ip=0.0.0.0-255.255.255.255 action=ip_deny method=PUSH|PURGE|DELETE",
			"src_ip=::-ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff action=ip_deny method=PUSH|PURGE|DELETE"),
	},
	{
		"odd whitespace",
		fmt.Sprintf("%s\n%s\n%s\n",
			"src_ip=127.0.0.1\taction=ip_allow\tmethod=ALL",
			"src_ip=::1  action=ip_allow  method=ALL",
			"src_ip=0.0.0.0-255.255.255.255 \taction=ip_deny  \t method=PUSH|PURGE|DELETE"),
	},
	{
		"multiline config with empty line",
		fmt.Sprintf("%s\n\n%s",
			"src_ip=0/0 action=ip_allow",
			"src_ip=0/0 action=ip_deny"),
	},
	{
		"many empty lines in config",
		fmt.Sprintf("\n%s\n\n%s",
			"src_ip=0/0 action=ip_deny\n",
			"src_ip=0/0 action=ip_allow method=GET\n"),
	},
}

func TestIPAllowConfig(t *testing.T) {

	// Negative Tests
	for _, test := range negativeTests {
		actual := ip_allow.Parse(test.Config)
		if actual == nil || actual.Code() != test.Expected {
			t.Errorf(`
  config: "%v"
  returned error: "%v"
  error should be related to: %v`, test.Config, actual, test.Description)
		}
	}

	// Positive Tests
	for _, test := range positiveTests {
		actual := ip_allow.Parse(test.Config)
		if actual != nil {
			t.Errorf(`
  config: "%v"
  returned error: "%v"
  error should be nil
  description: %v`, test.Config, actual, test.Description)
		}
	}
}

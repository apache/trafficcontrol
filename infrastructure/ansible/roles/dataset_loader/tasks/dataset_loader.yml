#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
- name: Get TO Cookie
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/user/login"
    method: POST
    body: '{ "u":"{{ dl_to_user }}", "p":"{{ dl_to_user_password }}" }'
    headers:
      Content-Type: "application/x-www-form-urlencoded"
  register: dl_mojo_token
  no_log: true
  retries: 10
  delay: 10

- name: Collect All CDN delegations assigned to Traffic Routers
  set_fact:
    tmp_cdnDelegation: "{{ hostvars[item]['cdn'] }}"
  with_items: "{{dl_hosts_tr}}"
  register: tmp_cdnDelegation_result

- name: Convert CDN Delegation facts to more usable list
  set_fact:
    cdnDelegationList: "{{ tmp_cdnDelegation_result.results | map(attribute='ansible_facts.tmp_cdnDelegation') | difference(excluded_cdn | lower) | map('lower') | list | unique }}"
  vars:
    excluded_cdn: ALL

- name: Get Primary CDN Delegation
  set_fact:
    cdnDelegationPrimary: "{{ cdnDelegationList | first }}"

- name: Get All CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: GET
  register: get_all_cdns
  no_log: true
  retries: 10
  delay: 10

- name: Update the Primary CDN
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns/{{ existing_primary_cdn.id }}"
    method: PUT
    body: "{{ dl_cdn }}"
  vars:
    name: "{{ dl_ds_merged_cdns[cdnDelegationPrimary].name | default(cdnDelegationPrimary) }}"
    domainName: "{{ cdnDelegationPrimary }}.{{ (dl_hosts_to | first).split('.')[1:] | join('.') | lower }}"
    dnssecEnabled: "{{ dl_ds_merged_cdns[cdnDelegationPrimary].dnssecEnabled | default(false) | lower }}"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    existing_primary_cdn: "{{ (get_all_cdns.json.response | to_json | lower | from_json) | selectattr('domainname', 'search', ('^'+cdnDelegationPrimary+'\\.')) | list | first }}"
  register: update_cdn_out
  failed_when: (update_cdn_out.status == 400 and update_cdn_out.json | to_json | from_json | json_query(error_query) | length != 0) or (update_cdn_out.status > 400 and update_cdn_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Create additional CDNs having delegations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: POST
    body: "{{ dl_cdn }}"
  with_items: "{{ cdnDelegationList | difference(cdnDelegationPrimary) | intersect(dl_ds_merged_cdns | map('lower') | list) + cdnDelegationList | difference(dl_ds_merged_cdns | map('lower') | list)}}"
  vars:
    name: "{{ item.name | default(item) }}"
    domainName: "{{ item }}.{{ (dl_hosts_to | first).split('.')[1:] | join('.') }}"
    dnssecEnabled: "{{ dl_ds_merged_cdns[item].dnssecEnabled | default(false) | lower }}"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cdns_out
  failed_when: (create_cdns_out.status == 400 and create_cdns_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cdns_out.status > 400 and create_cdns_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: GET
  register: get_all_cdns
  no_log: true
  retries: 10
  delay: 10
  until: get_all_cdns['status']|default(0) == 200

- name: Assign fqdn to cdn
  set_fact:
    cdn_assignments: "{{ (cdn_assignments | default({})) | combine({ item: hostvars[item].cdn }) }}"
  with_items: "{{ dl_hosts_all }}"

- name: Get All Tenants
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/tenants"
    method: GET
  register: get_all_tenants
  no_log: true
  retries: 10
  delay: 10
  until: get_all_tenants['status']|default(0) == 200

- name: Get All Roles
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/roles"
    method: GET
  register: get_all_roles
  no_log: true
  retries: 10
  delay: 10
  until: get_all_roles['status']|default(0) == 200

- name: Create Types
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/types"
    method: POST
    body:
      name: "{{ item.name }}"
      description: "{{ item.description }}"
      useInTable: "{{ item.useInTable }}"
  with_items: "{{ dl_ds_merged_types }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_types_out
  failed_when: (create_types_out.status == 400 and create_types_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_types_out.status > 400 and create_types_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Types
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/types"
    method: GET
  register: get_all_types
  no_log: true
  retries: 10
  delay: 10
  until: get_all_types['status']|default(0) == 200

- name: Create Users
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/users"
    method: POST
    body: "{{ lookup('template', 'user.j2') }}"
  with_items: "{{ dl_ds_merged_users }}"
  vars:
    role_query: "response[?name == '{{ item.role | default('read-only') }}'].id | [0]"
    tenant_query: "response[?name == '{{ item.tenant | default('root') }}'].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    user_password: "{{ item.password | default( lookup('password', '/dev/null length=32 chars=ascii_letters') ) }}"
    addressLine1: "{{ item.addressLine1 | default(omit) }}"
    addressLine2: "{{ item.addressLine2 | default(omit) }}"
    city: "{{ item.city | default(omit) }}"
    confirmLocalPasswd: "{{ user_password }}"
    company: "{{ item.company | default(omit) }}"
    email: "{{ item.email }}"
    fullName: "{{ item.fullName }}"
    localPasswd: "{{ user_password }}"
    newUser: "{{ item.newUser | default(omit) }}"
    phoneNumber: "{{ item.phoneNumber | default(omit) }}"
    postalCode: "{{ item.postalCode | default(omit) }}"
    publicSshKey: "{{ item.publicSshKey | default(omit) }}"
    role: "{{ get_all_roles.json | json_query(role_query) }}"
    stateOrProvince: "{{ item.stateOrProvince | default(omit) }}"
    tenantId: "{{ get_all_tenants.json | json_query(tenant_query) | default(omit) }}"
    username: "{{ item.username }}"
  register: create_user_out
  no_log: true
  retries: 10
  delay: 10
  failed_when: (create_user_out.status == 400 and create_user_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_user_out.status > 400 and create_user_out.status < 600)

- name: Get All Users
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/users"
    method: GET
  register: get_all_users

- name: Create Cachegroups - Traffic Router
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'TR_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)
  no_log: true
  retries: 10
  delay: 10

- name: Create Cachegroups - Infrastructure Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'TC_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)
  no_log: true
  retries: 10
  delay: 10

- name: Create Cachegroups - Origin Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'ORG_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Cachegroups - Origin Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups
  no_log: true
  retries: 10
  delay: 10
  until: get_all_cachegroups['status']|default(0) == 200

- name: Create Cachegroups - Mid Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    parent_query: "response[?name == '{{ item.parentCachegroup }}'].id | [0]"
    secondaryparent_query: "response[?name == '{{ item.secondaryParentCachegroup }}'].id | [0]"
    parentCachegroupId: "{{ get_all_cachegroups.json | json_query(parent_query) | default(omit) }}"
    secondaryparentCachegroupId: "{{ get_all_cachegroups.json | json_query(secondaryparent_query) | default(omit) }}"
    type_filter: "[?type == 'MID_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Cachegroups - Mid Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups
  no_log: true
  retries: 10
  delay: 10
  until: get_all_cachegroups['status']|default(0) == 200

- name: Create Cachegroups - Edge Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    parent_query: "response[?name == '{{ item.parentCachegroup }}'].id | [0]"
    secondaryparent_query: "response[?name == '{{ item.secondaryParentCachegroup }}'].id | [0]"
    parentCachegroupId: "{{ get_all_cachegroups.json | json_query(parent_query) | default(omit) }}"
    secondaryparentCachegroupId: "{{ get_all_cachegroups.json | json_query(secondaryparent_query) | default(omit) }}"
    type_filter: "[?type == 'EDGE_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Cachegroups
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups
  no_log: true
  retries: 10
  delay: 10
  until: get_all_cachegroups['status']|default(0) == 200

# Map of hosts to cachegroups
- name: Associate origins, caches, and routers to cachegroups
  set_fact:
    cachegroups_assignments: "{{ {} |combine(origins) | combine(edges) | combine(mids) | combine(trs) | combine(infra) }}"
  vars:
    origins: "{{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'ORG_LOC') | map(attribute='name') | list | associate_round_robin(dl_hosts_fakeorigin | union(dl_hosts_mso_alias)) | denormalize_association }}"
    edges: "{{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'EDGE_LOC') | map(attribute='name') | list | associate_round_robin(dl_hosts_atsec | union(dl_hosts_grove)) | denormalize_association }}"
    mids: "{{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'MID_LOC') | map(attribute='name') | list | associate_round_robin(dl_hosts_atsmid) | denormalize_association }}"
    trs: "{{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'TR_LOC') | map(attribute='name') | list | associate_round_robin(dl_hosts_tr) | denormalize_association }}"
    infra: "{{ ['infrastructure'] | associate_round_robin(dl_hosts_all | difference(dl_hosts_fakeorigin + dl_hosts_mso_alias + dl_hosts_atsec + dl_hosts_grove + dl_hosts_atsmid + dl_hosts_tr) ) | denormalize_association }}"

- name: Build reverse lookup for cachegroups to eligible phys_locations
  set_fact:
    cachegroup_lookup: "{{ cachegroup_lookup | default({}) | combine(vals) }}"
  with_items: "{{ dl_ds_merged_divisions | json_query(cachegroup_query) | unique }}"
  vars:
    cachegroup_query: "[*].regions[*].phys_locations[*].cachegroups[][][]"
    physlocation_query: "[*].regions[*].phys_locations[?contains(cachegroups,'{{ item }}')].name[][]"
    vals: "{{ [item] | associate_round_robin(dl_ds_merged_divisions | json_query(physlocation_query)) }}"

- name: Associate servers to physLocation
  set_fact:
    physlocation_assignments: "{{ physlocation_assignments | default({}) | combine( eligible_physlocations | associate_round_robin(servers_in_cachegroup) | denormalize_association ) }}"
  with_items: "{{ cachegroups_assignments.values() | list | unique }}"
  vars:
    eligible_physlocations: "{{ cachegroup_lookup[item] }}"
    servers_in_cachegroup: "{{ cachegroups_assignments | dict2items | json_query(fqdn_query) }}"
    fqdn_query: "[?value==`{{ item }}`].key"

- name: Create Division
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/divisions"
    method: POST
    body:
      name: "{{ item }}"
  with_items: "{{ dl_ds_merged_divisions | json_query(division_query) }}"
  vars:
    division_query: "[].division_name"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_divisions_out
  failed_when: (create_divisions_out.status == 400 and create_divisions_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_divisions_out.status > 400 and create_divisions_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Divisions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/divisions"
    method: GET
  register: get_all_divisions
  no_log: true
  retries: 10
  delay: 10
  until: get_all_divisions['status']|default(0) == 200

- name: Assemble assignments of region to division
  set_fact:
    region_assignments: "{{ (region_assignments | default({})) | combine(regions) }}"
  with_items: "{{ get_all_divisions.json.response }}"
  vars:
    region_query: "[?division_name == `{{ item.name }}`].regions[].{region_name: region_name, division_id: `{{ item.id }}`}"
    regions: "{{ dl_ds_merged_divisions | to_json | from_json | json_query(region_query) | items2dict(key_name='region_name',value_name='division_id') }}"

- name: Create Regions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/regions"
    method: POST
    body: >
      {
      "name": "{{ item.key }}",
      "division": {{ item.value | int}}
      }
  with_dict: "{{ region_assignments }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_regions_out
  failed_when: (create_regions_out.status == 400 and create_regions_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_regions_out.status > 400 and create_regions_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Regions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/regions"
    method: GET
  register: get_all_regions
  no_log: true
  retries: 10
  delay: 10
  until: get_all_regions['status']|default(0) == 200

- name: Constuct physLocation payload
  set_fact:
    physlocation_list: "{{ physlocation_list | default([]) + [ physlocations ] }}"
  with_items: "{{ get_all_regions.json.response  }}"
  vars:
    physloc_query: "[].regions[?region_name==`{{ item.name }}`][].phys_locations[].{value: {name: name, shortname: shortname, address: address, city: city, state: state, zip: zip, phone: phone, poc: poc, email: email, comments: comments, cachegroups: cachegroups, regionId: `{{ item.id }}`}}"
    physlocations: "{{ dl_ds_merged_divisions | to_json | from_json | json_query(physloc_query)  }}"

- name: Create Physical Locations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/phys_locations"
    method: POST
    body: >
        {
        "address": "{{ item.value.address }}",
        "city": "{{ item.value.city }}",
        "comments": "{{ item.value.comments | default(omit) }}",
        "email": "{{ item.value.email | default(omit) }}",
        "name": "{{ item.value.name }}",
        "phone": "{{ item.value.phone | default(omit) }}",
        "poc": "{{ item.value.poc | default(omit) }}",
        "shortName": "{{ item.value.shortname }}",
        "state": "{{ item.value.state }}",
        "zip": "{{ item.value.zip }}",
        "regionId": {{ item.value.regionId | int }}
        }
  with_items: "{{ physlocation_list }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_physlocation_out
  failed_when: (create_physlocation_out.status == 400 and create_physlocation_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_physlocation_out.status > 400 and create_physlocation_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Physical Locations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/phys_locations"
    method: GET
  register: get_all_physlocations
  no_log: true
  retries: 10
  delay: 10
  until: get_all_physlocations['status']|default(0) == 200

- name: Assign types to servers
  set_fact:
    type_assignments: "{{ (type_assignments | default({})) | combine({ item: dl_ds_merged_type_ansible_component_map[hostvars[item].component] | default('UNKNOWN') }) }}"
  with_items: "{{ dl_hosts_all }}"

- name: Assert a default location
  set_fact:
    default_location: dl_ds_merged_divisions | json_query(location_query)
  vars:
    location_query: "[].regions[].phys_locations[].name | [0]"

- name: Assert a default cachegroup
  set_fact:
    default_cachegroup: infrastructure

- name: Create and Assign Profiles and Parameters
  block:
    - name: Collect information about eligible cache block drives
      block:
        - name: Force fact collection on ats edges and mids as well as grove, if not already performed
          setup:
          with_items: "{{ dl_hosts_atsec+dl_hosts_atsmid+dl_hosts_grove }}"
          delegate_to: "{{ item }}"
          delegate_facts: True
          when: hostvars[item]['ansible_default_ipv4'] is not defined
          no_log: true

        - name: Fetch information about block without partitions and whitelisted prefixes
          set_fact:
            eligible_cache_disks_tmp: "{{ hostvars[item].ansible_facts.devices | dict2items | to_json | from_json | json_query(eligible_device_query) | sort }}"
          vars:
            eligible_device_query: "[?({{ dl_ds_merged_cache_block_device_prefix_whitelist | map('regex_replace', '^(.*)$', 'starts_with(key,`\\1`)==`true`') | list | join(' || ') }}) && length(value.partitions)==`0`].key"
          with_items: "{{ dl_hosts_atsec+dl_hosts_atsmid+dl_hosts_grove }}"
          register: eligible_cache_disks_tmp2

        - name: Assemble information about eligible cache block drives in a more useful way
          set_fact:
            eligible_cache_rotational_disks: "{{ eligible_cache_disks_tmp2.results | json_query(combine_eligible_cache_disks_from_results_query) | items2dict }}"
          vars:
            combine_eligible_cache_disks_from_results_query: "[].{key: item, value: ansible_facts.eligible_cache_disks_tmp}"

        - name: Fetch information about ram disks
          set_fact:
            eligible_cache_ram_disks_tmp: "{{ hostvars[item].ansible_facts.devices | dict2items | to_json | from_json | json_query(eligible_device_query) | sort }}"
          vars:
            eligible_device_query: "[?({{ dl_ds_merged_cache_ram_device_prefix_whitelist | map('regex_replace', '^(.*)$', 'starts_with(key,`\\1`)==`true`') | list | join(' || ') }}) && length(value.partitions)==`0`].key"
          with_items: "{{ dl_hosts_atsec+dl_hosts_atsmid+dl_hosts_grove }}"
          register: eligible_cache_ram_disks_tmp2

        - name: Assemble information about eligible cache ram drives in a more useful way
          set_fact:
            eligible_cache_ram_disks: "{{ eligible_cache_ram_disks_tmp2.results | json_query(combine_eligible_ram_disks_from_results_query) | items2dict }}"
          vars:
            combine_eligible_ram_disks_from_results_query: "[].{key: item, value: ansible_facts.eligible_cache_ram_disks_tmp}"

        - name: Combine hardware data of caches into a single data object
          set_fact:
            dl_ds_cache_hardware_info: "{{ (dl_ds_cache_hardware_info | default({})) | combine({ item: {'ram_disks': ram_disks, 'cache_disks': cache_disks, 'ram_cache_size': ram_cache_size, 'primary_network_interface': primary_network_interface, 'network_bandwidth_limit': network_bandwidth_limit, 'load_avg_limit': load_avg_limit } }) }}"
          with_items: "{{ dl_hosts_atsec+dl_hosts_atsmid+dl_hosts_grove }}"
          vars:
            ram_disks: "{{ eligible_cache_ram_disks[item] | default([]) }}"
            cache_disks: "{{ eligible_cache_rotational_disks[item] | default([]) }}"
            ram_cache_size: "{{ ((ram_cache_size_percentage | int) / 100 * ( hostvars[item].ansible_memtotal_mb | float ) * 1000000) | int }}"
            ram_cache_size_percentage: "{{ (hostvars[item].component == 'atsec') | ternary(dl_atsec_ram_cache_size_percentage,(hostvars[item].component == 'atsmid') | ternary(dl_atsmid_ram_cache_size_percentage,dl_grove_ram_cache_size_percentage)) }}"
            primary_network_interface: "{{ hostvars[item].ansible_default_ipv4.interface }}"
            network_bandwidth_limit: "{{ hostvars[item]['ansible_'+hostvars[item].ansible_default_ipv4.interface].speed }}"
            load_avg_limit: "{{ [10, hostvars[item].ansible_processor_vcpus * hostvars[item].ansible_processor_threads_per_core] | max }}"
      when: dl_ds_ats_hardware_info is not defined

    - name: Assemble mapping of hardware info to profile hardware index
      set_fact:
        cache_hardware_profile_index: "{{ cache_hardware_profile_index | default({}) | combine({profilename: item}) }}"
      loop: "{{ dl_ds_cache_hardware_info.values() | list | unique }}"
      loop_control:
        index_var: index
      vars:
        profilename: "hdwr{{ index }}"

    - name: Assemble information about hardware profiles in a more useful way
      set_fact:
        cache_hardware_profile_map: "{{ cache_hardware_profile_map | default({}) | combine({ item: { 'hardware_profile': cache_hardware_profile_index | dict2items | json_query(hw_lookup_query), 'component': hostvars[item].component } }) }}"
      with_items: "{{ dl_hosts_atsec+dl_hosts_atsmid+dl_hosts_grove }}"
      vars:
        hw_lookup_query: "[?value.ram_disks==`[{{ dl_ds_cache_hardware_info[item].ram_disks | map('to_json') | join(',') }}]` && value.cache_disks==`[{{ dl_ds_cache_hardware_info[item].cache_disks | map('to_json') | join(',') }}]` && value.ram_cache_size=='{{ dl_ds_cache_hardware_info[item].ram_cache_size }}'].key |[0]"

    - name: Get All Profiles
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
        method: GET
      register: get_all_profiles
      no_log: true
      retries: 10
      delay: 10
      until: get_all_profiles['status']|default(0) == 200

    - name: Get All Parameters from GLOBAL profile
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/GLOBAL/parameters"
        method: GET
      register: get_global_parameters
      no_log: true
      retries: 10
      delay: 10
      until: get_global_parameters['status']|default(0) == 200

    - name: Unlink all Global Profile parameters to be recreated
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profileparameters/{{ get_all_profiles.json | to_json | from_json | json_query(profile_query) }}/{{ item }}"
        method: DELETE
      with_items: "{{ get_global_parameters.json.response | map(attribute='id') | list }}"
      vars:
        profile_query: "response[?name == 'GLOBAL'].id | [0]"
        error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
      register: unassociate_global_params
      failed_when: (unassociate_global_params.status == 400 and unassociate_global_params.json | to_json | from_json | json_query(error_query) | length != 0) or ( unassociate_global_params.status > 400 and unassociate_global_params.status < 600)
      no_log: true
      retries: 10
      delay: 10

    - name: Create Profiles - Global
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
        method: POST
        body: "{{ lookup('template', 'profile.j2') }}"
      with_items: "{{ dl_ds_merged_profiles }}"
      vars:
        name: "{{ item.name }}"
        description: "{{ item.description }}"
        cdn: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
        type: "{{ item.type }}"
        routingDisabled: "{{ (item.routingDisabled | default(false)) | lower }}"
        cdn_query: "response[?starts_with(domainName,`{{ item.cdn | default(all) }}`) == `true` || name == `{{ item.cdn | default(all) }}`].id | [0]"
        error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
      register: create_profiles_out
      failed_when: (create_profiles_out.status == 400 and create_profiles_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_profiles_out.status > 400 and create_profiles_out.status < 600)
      no_log: true
      retries: 10
      delay: 10

    - name: Create and Associate Parameters - Global
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/{{ item.name }}/parameters"
        method: POST
        body: "{{ lookup('template', 'parameter.j2') }}"
      with_items:
        - "{{ dl_ds_merged_profiles }}"
      vars:
        paramset: "{{ item.parameters | default([]) }}"
        cdn_query: "response[?starts_with(domainName,`{{ item.cdn | default(ALL) | lower }}`) == `true` || name == `{{ item.cdn | default(ALL) }}`].id | [0]"
        error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
      register: create_profiles_out
      failed_when: (create_profiles_out.status == 400 and create_profiles_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_profiles_out.status > 400 and create_profiles_out.status < 600)
      no_log: true
      retries: 10
      delay: 10

    - name: Handle Profile & Parameter CDN Templates
      include_tasks: parameter_loader.yml
      vars:
        Target_cdn_delegation_fqdn: "{{ Target_cdn_delegation | default(mkga) }}.{{ (dl_hosts_to | first).split('.')[1:] | join('.') | lower }}"
        Target_cdn_name: "{{ get_all_cdns.json | to_json | from_json | json_query(cdnName_query) }}"
        Target_cdn_id: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
        cdnName_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation }}`) == `true`].name | [0]"
        cdn_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation }}`) == `true`].id | [0]"
      with_items: "{{ cdnDelegationList }}"
      loop_control:
        loop_var: Target_cdn_delegation

    - name: Get All Profiles
      uri:
        url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
        method: GET
      register: get_all_profiles
      no_log: true
      retries: 10
      delay: 10
      until: get_all_profiles['status']|default(0) == 200

    - name: Get all Parameters per Profile - with curl workaround
      command: "curl -X GET -Lsk --fail -b '{{ dl_mojo_token.set_cookie }}' '{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/{{ item }}/parameters'"
      args:
        warn: no
      with_items: "{{ get_all_profiles.json.response | map(attribute='name') | list }}"
      register: get_all_parameters_by_profile_raw
      no_log: true
      retries: 10
      delay: 10

    - name: Convert the curl workaround output to match normal URI output
      set_fact:
        get_all_parameters_by_profile: "{{ (get_all_parameters_by_profile | default({})) | combine(payload, recursive=True) }}"
      with_items: "{{ get_all_parameters_by_profile_raw.results }}"
      no_log: true
      vars:
        payload: "{'changed': false,'msg': 'All items completed, includes curl workaround', 'results': {{ results }} }"
        results: "{{ ((get_all_parameters_by_profile | default({})).results | default([])) + [ new_result ] }}"
        new_result: "{{ item | combine({'json': ( item.stdout | from_json ) }) }}"

    - name: Associate eligible profiles to hosts
      set_fact:
        profile_assignments: "{{ dl_hosts_all | associate_profile_to_servers(profile_names,cache_hardware_profile_map,hostvars,dl_ds_merged_profile_prefix_ansible_component_map) }}"
      vars:
        profile_names: "{{ get_all_profiles.json.response | map(attribute='name') | list | map('lower') | list | unique | sort }}"

- name: Get All Server Statuses
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/statuses"
    method: GET
  register: get_all_statuses
  no_log: true
  retries: 10
  delay: 10
  until: get_all_statuses['status']|default(0) == 200

- name: Get the CDN Assignments into a more queryable form
  set_fact:
    cdn_assignment_reverse_tmp: "{{ cdn_assignment_reverse_tmp | default([]) + [{'host': item.key, 'cdn': item.value}] }}"
  with_dict: "{{ cdn_assignments }}"

- name: Map CDN Delegation to CDN Name
  set_fact:
    delegation_cdnName_map: "{{ (delegation_cdnName_map | default({})) | combine({ (tmp | lower): (item.name | lower) }) }}"
  with_items: "{{ get_all_cdns.json.response }}"
  vars:
    tmp: "{{ (item.domainName == '-') | ternary('ALL', (item.domainName.split('.')[0])) }}"

- name: Divide TM hosts in half per CDN (Phase 1)
  set_fact:
    tm_status_tmp: "{{ tm_status_tmp | default([]) + [ {'onlineTM': evenTM, 'offlineTM': oddTM} ] }}"
  with_items: "{{ delegation_cdnName_map.keys() }}"
  vars:
    lc_cdn_assignment_reverse_tmp: "{{ cdn_assignment_reverse_tmp | lower }}"
    cdn_query: "[?cdn == `{{ item }}`].host"
    cdns: "{{ lc_cdn_assignment_reverse_tmp | json_query(cdn_query) }}"
    tm_cdns: "{{ dl_hosts_tm | intersect(cdns) }}"
    evenTM: "{{ (dl_hosts_tm | intersect(cdns))[::2] }}"
    oddTM: "{{ (dl_hosts_tm | intersect(cdns))[1::2] }}"

- name: Assign server status for offline traffic monitors
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'OFFLINE' }) }}"
  with_items: "{{ tm_status_tmp | json_query(offline_query) }}"
  vars:
    offline_query: "[].offlineTM[]"

- name: Assign server status for online traffic monitors
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'ONLINE' }) }}"
  with_items: "{{ tm_status_tmp | json_query(online_query) }}"
  vars:
    online_query: "[].onlineTM[]"

- name: Assign server status for caches
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'REPORTED' }) }}"
  with_items: "{{ dl_hosts_atsec + dl_hosts_atsmid + dl_hosts_grove }}"
  
# Due to data manipulation being a shortcome of ansible, in these next set of tasks we are extracting 
# interface data that is needed for server creation for dual homing puposes from ansible facts and 
# storing the final result in dl_all_interfaces var
          
- name: Set tmp var to store all pertinent interfaces data from ansible facts for each host
  set_fact:
    _dl_all_ifaces_tmp_1: "{{ (_dl_all_ifaces_tmp_1 | default([])) + [ifaces] }}"
  loop: "{{ hostvars | to_json | replace(replacestr, '') | from_json | json_query(loop_query) | subelements('all_ifaces') }}"
  loop_control:
    label: "{{ item.0.host_name }} - {{ item.1 }}"
  when: 'ifaces != ""'
  vars:
    loop_query: "* | [].{host_name: inventory_hostname, hostvrs: @, all_ifaces: @.ansible_interfaces || `[]`}" # || used to set default value to empty list
    replacestr: "{{ '{{' }}"
    iface_query: "[ansible_{{ item.1 }}] | [? (ipv4 || ipv6) && length(ipv6[?!starts_with(address,`fe80`) && scope == `global`]) > `0` && (type == `ether` || type == `bonding`)] | [0] | {iface_name: device, v6_addresses: ipv6[?!starts_with(address,`fe80`) && scope == `global`], host: `{{ item.0.host_name }}`, mtu: mtu, v4_address: ipv4}"
    ifaces: "{{ item.0.hostvrs | json_query(iface_query) }}"

- name: Set var to add checks for v6 slaac address and service address to tmp var for all interfaces
  set_fact: 
    _dl_all_ifaces_tmp_2: "{{ _dl_all_ifaces_tmp_2 | default({}) | combine({ host_key: combined_result }) }}"
  loop: "{{ _dl_all_ifaces_tmp_1 | subelements('v6_addresses') }}"
  loop_control:
    label: "{{ item.0.host }} - {{item.1.address}}"
  vars:
    v6_start: "{{ (item.1.address.split(':')[:-1]) | join(':') }}"
    v6_start_regex: "{{ v6_start }}.+"
    v6_addr_list: "{{ item.0.v6_addresses | difference([item.1]) | map(attribute='address') | list }}"
    v6_addr_starts_with: "{{ v6_addr_list | select('match',v6_start_regex) | list }}"
    is_v6_slaac_addr: "{{ true if (v6_addr_list | length > 0) and ( v6_addr_list | select('match',v6_start_regex) | list | length == 0) else false }}"
    default_v6_addr: "{{ hostvars[item.0.host].ipv6_service_address | default(hostvars[item.0.host].ansible_default_ipv6.address) }}"
    is_v6_service_addr: "{{ true if ((item.1.address == default_v6_addr) and (( v6_addr_list | length ) == 0)) or (not is_v6_slaac_addr and ( v6_addr_list | length ) > 0) else false }}"
    tmp_host_key: "{{ item.0.host }}.{{ item.0.iface_name}}"
    host_key: "{{ tmp_host_key | replace('.','_') | replace('-','_') }}" # parsing error using '.' in host_key
    result: "{{ item.1 | combine({'is_v6_slaac_addr': is_v6_slaac_addr, 'is_service_address': is_v6_service_addr}) }}"
    host_query: "{{ host_key }}.host | [0]"
    iface_query: "{{ host_key }}.iface_name | [0]"
    mtu_query: "{{ host_key }}.mtu | [0]"
    v4_addr_query: "{{ host_key }}.v4_address | [0]"
    v6_addr_query: "{{ host_key }}.v6_addresses"
    combined_result:
      host: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(host_query) | default(item.0.host, true) }}"
      iface_name: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(iface_query) | default(item.0.iface_name, true) }}"
      mtu: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(mtu_query) | default(item.0.mtu, true) }}"
      v4_address: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(v4_addr_query) | default(item.0.v4_address, true) }}"
      v6_addresses: "{{ ((_dl_all_ifaces_tmp_2 | default({})) | json_query(v6_addr_query) | default([], true)) + [result] }}"

- name: Set var to add v4 service address check to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_3: "{{ (_dl_all_ifaces_tmp_3 | default([])) + [ item | combine({'v4_address': {'is_service_address': is_v4_service_addr } }, recursive=True)] }}"
  loop: "{{ _dl_all_ifaces_tmp_2 | dict2items | map(attribute='value') | list }}"
  loop_control:
    label: "{{ item.host }} - {{ item.iface_name }}"
  vars:
    is_v4_service_addr: "{{ true if item.v4_address.address == hostvars[item.host].ansible_default_ipv4.address else false }}"

- name: Get ip gateway information from shell
  shell: "if [ \"$(`which ip` -{{ item.ip_family }} route show {{ item.address }}/{{ item.suffix }} | grep via)\" == \"\" ]; then `which ip` -{{ item.ip_family }} route show | grep default | grep -vE ' fe80| 127.' | cut -f3 -d' ';else `which ip` -{{ item.ip_family }} route show {{ item.address }}/{{ item.suffix }} | cut -f3 -d' '; fi"
  loop: "{{ _dl_all_ifaces_tmp_3 | json_query(ipObject_query) }}"
  register: ipAddress_gateways
  changed_when: false
  environment:
    PATH: "{{ lookup('env', 'PATH') }}:/usr/local/sbin:/usr/sbin:/sbin"
  vars:
    ipObject_query: "[] | { v4_address: [].{ host: host, address: v4_address.address, suffix: v4_address.netmask, ip_family: `4` }, v6_addresses: [].{ address: @.v6_addresses[0].address, host: host, suffix: @.v6_addresses[0].prefix, ip_family: `6` } } | *[]"
  delegate_to: "{{ item.host }}"

- name: Get interface speed to determine max maxBandwidth
  shell: "cat /sys/class/net/{{ item.iface_name }}/speed"
  loop: "{{ _dl_all_ifaces_tmp_3 | json_query(iface_query) }}"
  register: iface_total_bandwidth
  changed_when: false
  environment:
    PATH: "{{ lookup('env', 'PATH') }}:/usr/local/sbin:/usr/sbin:/sbin"
  vars:
    iface_query: "[].{ host: host, iface_name: iface_name }"
  failed_when: false
  delegate_to: "{{ item.host }}"

- name: Set var for adding v6 gateway information to to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_4: "{{ _dl_all_ifaces_tmp_4 | default({}) | combine({ hostAsKey: combined_result }) }}"
  loop: "{{ _dl_all_ifaces_tmp_3 | subelements('v6_addresses') }}"
  loop_control:
    label: "{{ item.0.host }} - {{ item.1.address }}"
  vars:
    v6gateway_query: "[?item.address == `{{ item.1.address }}`] |[0].stdout"
    v6gateway: "{{ (((ipAddress_gateways.results | json_query(v6gateway_query)) if ipAddress_gateways.results | json_query(v6gateway_query) != '' else (v6_cidr_address | ipaddr('1'))).split('/'))[0] }}"
    v6_cidr_address: "{{ item.1.address }}/{{ item.1.prefix }}"
    tmp_hostAsKey: "{{ item.0.host }}.{{ item.0.iface_name }}"
    hostAsKey: "{{ tmp_hostAsKey | replace('.','_') | replace('-','_') }}"
    result: "{{ item.1 | combine({'gateway': v6gateway, 'address': v6_cidr_address}) }}"
    host_query: "{{ hostAsKey }}.host | [0]"
    iface_query: "{{ hostAsKey }}.iface_name | [0]"
    mtu_query: "{{ hostAsKey }}.mtu | [0]"
    v4_address_query: "{{ hostAsKey }}.v4_address | [0]"
    v6_addresses_query: "{{ hostAsKey }}.v6_addresses"
    combined_result:
      host: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(host_query) | default(item.0.host, true) }}"
      iface_name: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(iface_query) | default(item.0.iface_name, true) }}"
      mtu: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(mtu_query) | default(item.0.mtu, true) }}"
      v4_address: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(v4_address_query) | default(item.0.v4_address, true) }}"
      v6_addresses: "{{ ((_dl_all_ifaces_tmp_4 | default({})) | json_query(v6_addresses_query) | default([], true)) + [result] }}"
  
- name: Set var to adding v4 gateway and interface total bandwidth to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_5: "{{ _dl_all_ifaces_tmp_5 | default ([]) + [item | combine({'iface_total_bandwidth': totalBandwidth, 'v4_address': {'gateway': v4gateway, 'address': v4_cidr_address } }, recursive=True)] }}"
  loop: "{{ _dl_all_ifaces_tmp_4 | dict2items | map(attribute='value') | list }}"
  loop_control:
    label: "{{ item.host }} - {{ item.v4_address.address }}"
  vars:
    v4gateway_query: "[?item.address == `{{ item.v4_address.address}}`] |[0].stdout"
    v4gateway: "{{ ((ipAddress_gateways.results | json_query(v4gateway_query)).split('/'))[0] }}"
    v4_cidr_address: "{{ item.v4_address.address }}/{{ net_cidr_address | ipaddr('prefix') }}"
    net_cidr_address: "{{ item.v4_address.network }}/{{ item.v4_address.netmask }}"
    totalBandwidth_query: "[?item == `{{ item.iface_name }}`] | to_number([0].stdout)"
    totalBandwidth: "{{  iface_total_bandwidth.results | json_query(totalBandwidth_query)}}"

- name: Set Fact for all interfaces with required data for server creation
  set_fact: 
    dl_all_interfaces: "{{ (dl_all_interfaces | default({})) | combine({ item.0.key: [serverIfacePayload] }, recursive=True, list_merge='append') }}"
  loop: "{{ ifaceObject | subelements('value') }}"
  loop_control: 
    label: "{{ item.0.key }} - {{ item.1.name }}"
  vars: 
    ifaceObject_query: "[].{ key: host, value: [{name: iface_name, max_bandwidth: iface_total_bandwidth, mtu: to_number(mtu), ipAddresses: ({v4_address: [v4_address], v6_address: v6_addresses} | *[].{address: address, gateway: gateway, serviceAddress: is_service_address })}]}"
    ifaceObject: "{{ _dl_all_ifaces_tmp_5 | json_query(ifaceObject_query) }}"
    monitor_interface_query: "ipAddresses[] | [?serviceAddress == `true`]"
    monitor_interface: "{{ true if (item.1 | json_query(monitor_interface_query) | length) > 0 else false }}"
    serverIfacePayload: "{{ item.1 | combine({'monitor': monitor_interface, 'max_bandwidth': (max_bandwidth | int) }, recursive=True) }}"
    bandwidth: "{{ (item.1.max_bandwidth | default(1000, true)) | int }}"
    max_bandwidth_by_limit: "{{ bandwidth - (reserved_interface_bandwidth_lookup[bandwidth]) if reserved_interface_bandwidth_lookup is defined and reserved_interface_bandwidth_lookup[bandwidth] is defined }}"
    max_bandwidth_by_percent: "{{ (bandwidth|int) - ((bandwidth|int)/(reserved_interface_bandwidth_percent | default(80) | int )) }}"
    max_bandwidth: "{{ max_bandwidth_by_limit | default(max_bandwidth_by_percent,true) }}"

- name: Create Servers (Non-mso)
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: POST
    body: "{{ lookup('template', 'server.j2') }}"
  with_items: "{{ dl_hosts_all | difference(dl_hosts_mso_alias) }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!(contains(@,'already exists') || contains(@,'ipAddress is not unique across the server'))]"
    status_name: "{{ status_assignment[item] | default('ONLINE') }}"
    status_query: "[?name == `{{ status_name }}`].id | [0]"
    status_id: "{{ get_all_statuses.json.response | to_json | from_json | json_query(status_query) }}"
    cachegroup_name: "{{ cachegroups_assignments[item] | default('infrastructure') }}"
    cachegroup_query: "[?name == `{{ cachegroup_name }}`].id | [0]"
    cachegroup_id: "{{ get_all_cachegroups.json.response | to_json | from_json | json_query(cachegroup_query) }}"
    location_name: "{{ physlocation_assignments[item] | default('Baltimore-MD') }}"
    location_query: "[?name == `{{ location_name }}`].id | [0]"
    location_id: "{{ get_all_physlocations.json.response | to_json | from_json | json_query(location_query) }}"
    type_name: "{{ type_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    type_query: "[?name == `{{ type_name }}`].id | [0]"
    type_id: "{{ get_all_types.json.response | to_json | from_json | json_query(type_query) }}"
    lc_profiles: "{{ get_all_profiles.json.response | lower }}"
    profile_name: "{{ profile_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    profile_query: "[?name == `{{ profile_name }}`].id | [0]"
    profile_id: "{{ lc_profiles | to_json | from_json | json_query(profile_query) }}"
    lc_cdns: "{{ get_all_cdns.json.response | lower }}"
    cdn_name: "{{ delegation_cdnName_map[cdn_assignments[item] | lower ] }}"
    cdn_query: "[?starts_with(name,`{{ cdn_name | lower }}`)].id | [0]"
    cdn_id: "{{ lc_cdns | to_json | from_json | json_query(cdn_query) }}"
    hostName: "{{ item.split('.')[0] }}"
    domainName: "{{ item.split('.')[1:] | join('.') }}"
    cachegroupId: "{{ cachegroup_id }}"
    statusId: "{{ status_id }}"
    physLocationId: "{{ location_id }}"
    typeId: "{{ type_id }}"
    profileId: "{{ profile_id }}"
    cdnId: "{{ cdn_id }}"
    updPending: True
    interfaces: "{{ dl_all_interfaces[item] }}"
    default_inventory_hostname: "{{ hostvars[item].component | default('server') }}.kabletown.invalid"
    merged_server_attrs: "{{ dl_ds_merged_servers['server.kabletown.invalid'] | combine(dl_ds_merged_servers[default_inventory_hostname] | default({}) ) | combine(dl_ds_merged_servers[item] | default({}) ) }}"
    tcpPort: "{{ merged_server_attrs.tcpPort | default(omit) }}"
    httpsPort: "{{ merged_server_attrs.httpsPort | default(omit) }}"
    xmppId: "{{ merged_server_attrs.xmppId | default(omit) }}"
    xmppPasswd: "{{ merged_server_attrs.xmppPasswd | default(omit) }}"
    rack: "{{ merged_server_attrs.rack | default(omit) }}"
    mgmtIpAddress: "{{ merged_server_attrs.mgmtIpAddress | default(omit) }}"
    mgmtIpNetmask: "{{ merged_server_attrs.mgmtIpNetmask | default(omit) }}"
    mgmtIpGateway: "{{ merged_server_attrs.mgmtIpGateway | default(omit) }}"
    iloIpAddress: "{{ merged_server_attrs.iloIpAddress | default(omit) }}"
    iloIpNetmask: "{{ merged_server_attrs.iloIpNetmask | default(omit) }}"
    iloIpGateway: "{{ merged_server_attrs.iloIpGateway | default(omit) }}"
    iloUsername: "{{ merged_server_attrs.iloUsername | default(omit) }}"
    iloPassword: "{{ merged_server_attrs.iloPassword | default(omit) }}"
    routerHostName: "{{ merged_server_attrs.routerHostName | default(omit) }}"
    routerPortName: "{{ merged_server_attrs.routerPortName | default(omit) }}"
  register: create_server_out
  failed_when: (create_server_out.status == 400 and create_server_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_server_out.status > 400 and create_server_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

###
# MSO servers are not guarenteed to be idempotent
# There exists an order of execution issue with regard to doing DS creation last
# This prevents you from knowing how to associate DS -> Eligible Server Profiles -> Servers -> MSO DS Server Assignments
# At present you have Profiles -> Servers -> DS -> Update MSO Server Profiles (to match specified eligibility) -> MSO DS Server Assignments
# This being said, it's only a broken idempotency so for CI/One-n-done purposes, it still works
###

- name: Create Servers (MSO)
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: POST
    body: "{{ lookup('template', 'server.j2') }}"
  with_items: "{{ dl_hosts_mso_alias }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!(contains(@,'already exists') || contains(@,'ipAddress is not unique across the server'))]"
    status_name: "{{ status_assignment[item] | default('ONLINE') }}"
    status_query: "[?name == `{{ status_name }}`].id | [0]"
    status_id: "{{ get_all_statuses.json.response | to_json | from_json | json_query(status_query) }}"
    cachegroup_name: "{{ cachegroups_assignments[item] | default('infrastructure') }}"
    cachegroup_query: "[?name == `{{ cachegroup_name }}`].id | [0]"
    cachegroup_id: "{{ get_all_cachegroups.json.response | to_json | from_json | json_query(cachegroup_query) }}"
    location_name: "{{ physlocation_assignments[item] | default('Baltimore-MD') }}"
    location_query: "[?name == `{{ location_name }}`].id | [0]"
    location_id: "{{ get_all_physlocations.json.response | to_json | from_json | json_query(location_query) }}"
    type_name: "{{ type_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    type_query: "[?name == `{{ type_name }}`].id | [0]"
    type_id: "{{ get_all_types.json.response | to_json | from_json | json_query(type_query) }}"
    lc_profiles: "{{ get_all_profiles.json.response | lower }}"
    profile_name: "{{ profile_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    profile_query: "[?name == `{{ profile_name }}`].id | [0]"
    profile_id: "{{ lc_profiles | to_json | from_json | json_query(profile_query) }}"
    lc_cdns: "{{ get_all_cdns.json.response | lower }}"
    cdn_name: "{{ delegation_cdnName_map[cdn_assignments[item] | lower ] }}"
    cdn_query: "[?starts_with(name,`{{ cdn_name | lower }}`)].id | [0]"
    cdn_id: "{{ lc_cdns | to_json | from_json | json_query(cdn_query) }}"
    hostName: "{{ item.split('.')[0] }}"
    domainName: "{{ item.split('.')[1:] | join('.') }}"
    cachegroupId: "{{ cachegroup_id }}"
    statusId: "{{ status_id }}"
    physLocationId: "{{ location_id }}"
    typeId: "{{ type_id }}"
    profileId: "{{ profile_id }}"
    cdnId: "{{ cdn_id }}"
    updPending: True
    interfaces:
      - maxBandwidth: null
        monitor: true
        mtu: 9000
        name: "eth0"
        ipAddresses:
          - address: "{{ hostvars[item].ansible_host }}"
            gateway: "127.0.0.0"
            serviceAddress: true
    default_inventory_hostname: "{{ hostvars[item].component | default('server') }}.kabletown.invalid"
    merged_server_attrs: "{{ dl_ds_merged_servers['server.kabletown.invalid'] | combine(dl_ds_merged_servers[default_inventory_hostname] | default({}) ) | combine(dl_ds_merged_servers[item] | default({}) ) }}"
    tcpPort: "{{ merged_server_attrs.tcpPort | default(omit) }}"
    httpsPort: "{{ merged_server_attrs.httpsPort | default(omit) }}"
    xmppId: "{{ merged_server_attrs.xmppId | default(omit) }}"
    xmppPasswd: "{{ merged_server_attrs.xmppPasswd | default(omit) }}"
    rack: "{{ merged_server_attrs.rack | default(omit) }}"
    mgmtIpAddress: "{{ merged_server_attrs.mgmtIpAddress | default(omit) }}"
    mgmtIpNetmask: "{{ merged_server_attrs.mgmtIpNetmask | default(omit) }}"
    mgmtIpGateway: "{{ merged_server_attrs.mgmtIpGateway | default(omit) }}"
    iloIpAddress: "{{ merged_server_attrs.iloIpAddress | default(omit) }}"
    iloIpNetmask: "{{ merged_server_attrs.iloIpNetmask | default(omit) }}"
    iloIpGateway: "{{ merged_server_attrs.iloIpGateway | default(omit) }}"
    iloUsername: "{{ merged_server_attrs.iloUsername | default(omit) }}"
    iloPassword: "{{ merged_server_attrs.iloPassword | default(omit) }}"
    routerHostName: "{{ merged_server_attrs.routerHostName | default(omit) }}"
    routerPortName: "{{ merged_server_attrs.routerPortName | default(omit) }}"
  register: create_server_out
  failed_when: (create_server_out.status == 400 and create_server_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_server_out.status > 400 and create_server_out.status < 600)
  no_log: true
  retries: 10
  delay: 10

- name: Get All Servers
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: GET
  register: get_all_servers
  no_log: true
  retries: 10
  delay: 10
  until: get_all_servers['status']|default(0) == 200

- name: Convert the CDN Delegation list into an index
  set_fact:
    cdnDelegationIndex: "{{ (cdnDelegationIndex | default({}) ) | combine( { item.1: item.0 } ) }}"
  with_indexed_items: "{{ cdnDelegationList }}"

- name: Create Index of Fake Origins
  set_fact:
    foIndex: "{{ (foIndex | default({}) ) | combine( { item.1: item.0 } ) }}"
  with_indexed_items: "{{ dl_hosts_fakeorigin }}"

- name: Assert we have enough Delivery Service CName records to go around
  assert:
    that:
      - (hostvars[dl_hosts_fakeorigin | first].ds_names.split(',') | length) >= (dl_ds_merged_ds_template | length)
    success_msg: "Enough Delivery CNames Exist ({{ dl_ds_merged_ds_template | length }}/{{ hostvars[dl_hosts_fakeorigin | first].ds_names.split(',') | length }})"
    fail_msg: "Not enough DS CNames exist to cover all DS.  Please go and create {{ (dl_ds_merged_ds_template | length) - (hostvars[dl_hosts_fakeorigin | first].ds_names.split(',') | length) }} more and rerun."
  vars:
    Target_cdn_delegation: Invalid (just for rendering)

- name: Handle Delivery Service CDN Templates
  include_tasks: ds_loader.yml
  vars:
    Target_cdn_delegation_fqdn: "{{ Target_cdn_delegation | default(mkga) }}.{{ (dl_hosts_to | first).split('.')[1:] | join('.') | lower }}"
    Target_cdn_name: "{{ get_all_cdns.json | to_json | from_json | json_query(cdnName_query) }}"
    Target_cdn_id: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
    cdnName_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation }}`) == `true`].name | [0]"
    cdn_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation }}`) == `true`].id | [0]"
  with_items: "{{ cdnDelegationList }}"
  loop_control:
    loop_var: Target_cdn_delegation

- name: Get All Delivery Services
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices"
    method: GET
  register: get_all_ds
  no_log: true
  retries: 10
  delay: 10
  until: get_all_ds['status']|default(0) == 200

- name: Render Federations Lists
  with_items: "{{ cdnDelegationList }}"
  loop_control:
    loop_var: Target_cdn_delegation
  set_fact:
    federations_for_cdn_delegation: "{{ dl_ds_default_federations }}"
  register: federations_out

- name: Create Federations
  vars:
    federations_query: 'results[].ansible_facts[].federations_for_cdn_delegation[]'
  with_items: "{{ federations_out | json_query(federations_query) }}"
  loop_control:
    loop_var: federation
  include_tasks: federation_loader.yml

- name: Ensure SSL info directory exists
  file:
    state: directory
    path: "{{ lookup('env', 'PWD') }}/out/ssl"
  delegate_to: localhost

- name: Set a default list of HTTPS DS
  set_fact:
    scrubbed_https_ds: []

- name: Scrub the protocol out of HTTS DS URLs
  set_fact:
    scrubbed_https_ds: "{{ scrubbed_https_ds | default([]) + [ combined ] }}"
  with_items: "{{ get_all_ds.json | to_json | from_json | json_query(https_query) }}"
  vars:
    https_query: "response[?protocol >= `2` ].{ xmlId: xmlId, exampleURLs: exampleURLs[? starts_with(@, `https`) ], cdnName: cdnName, is_http: ( contains(type, `HTTP`) ) }"
    fqdns: "{{ item.exampleURLs | map('regex_replace', 'https://^(.*)', '\\1') | list }}"
    base_fqdns: "{{ fqdns | map('regex_replace', '.*?\\.(.*)', 'DNS:\\1') | list }}"
    sans: "{% if item.is_http %}{{ (fqdns | map('regex_replace', '.*?\\.(.*)', 'DNS:*.\\1') | list) + base_fqdns }}{% else %}{{ fqdns | map('regex_replace', '^(.*)', 'DNS:\\1') | list }}{% endif %}"
    combined: "{{ item | combine( {'fqdns': fqdns, 'sans': sans} ) }}"

- name: Generate DS Private keys
  openssl_privatekey:
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    force: yes
  with_items: "{{ scrubbed_https_ds }}"
  delegate_to: localhost
  no_log: true

- name: Generate DS CSRs
  openssl_csr:
    privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    subject:
      CN: "{{ (item.sans | first).split(':')[1] }}"
      C: US
      ST: Colorado
      L: Denver
      O: Kabletown
      OU: CDN
      emailAddress: Ops@kabletown.invalid
    subject_alt_name: "{{ item.sans }}"
    key_usage:
      - digitalSignature
      - keyEncipherment
    extended_key_usage:
      - serverAuth
    basic_constraints:
      - CA:FALSE
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    force: yes
  delegate_to: localhost
  with_items: "{{ scrubbed_https_ds }}"

- name: Generate DS Certificates
  openssl_certificate:
    csr_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    force: yes
    issuer:
      CN: CDNLAB.invalid
      C: US
      ST: Colorado
      L: Denver
      O: Kabletown
      OU: CDN
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.crt"
    privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    provider: ownca
    ownca_path: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.crt"
    ownca_privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.key.pem"
  delegate_to: localhost
  with_items: "{{ scrubbed_https_ds }}"
  no_log: true

- name: Generate TO Self-signed certs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices/sslkeys/generate"
    method: POST
    body:
      cdn: "{{ item.cdnName }}"
      city: Denver
      country: US
      hostname: "{{ (item.sans | first).split(':')[1] }}"
      key: "{{ item.xmlId }}"
      organization: Kabletown
      state: CO
      businessUnit: CDN
      deliveryservice: "{{ item.xmlId }}"
      version: 1
  with_items: "{{ scrubbed_https_ds }}"
  no_log: true
  retries: 10
  delay: 10

- name: Upload DS SSL Data to Traffic Ops
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices/sslkeys/add"
    method: POST
    body:
      key: "{{ item.xmlId }}"
      version: 2
      cdn: "{{ item.cdnName }}"
      hostname: "{{ (item.sans | first).split(':')[1] }}"
      certificate:
        key: "{{ lookup('file', keypath) }}"
        csr: "{{ lookup('file', csrpath) }}"
        crt: |
          {{ lookup('file', crtpath) }}
          {{ lookup('file', intcertpath) }}
  delegate_to: localhost
  with_items: "{{ scrubbed_https_ds }}"
  register: create_ds_sslkeys_out
  failed_when: (create_ds_sslkeys_out.status == 400 and create_ds_sslkeys_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_ds_sslkeys_out.status > 400 and create_ds_sslkeys_out.status < 600)
  no_log: true
  retries: 10
  delay: 10
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    keypath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    csrpath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    crtpath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.crt"
    intcertpath: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.crt"

- name: Snapshot all CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/snapshot?cdn={{ item.name }}"
    method: PUT
  with_items: "{{ get_all_cdns.json.response[1:] }}"
  register: snapshot_out
  failed_when: (snapshot_out.status == 400 and snapshot_out.json | to_json | from_json | json_query(error_query) | length != 0) or (snapshot_out.status > 400 and snapshot_out.status < 600)
  no_log: true
  retries: 10
  delay: 10
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"

{"version":3,"sources":["meteor://ðŸ’»app/packages/iron_location/lib/utils.js","meteor://ðŸ’»app/packages/iron_location/lib/state.js","meteor://ðŸ’»app/packages/iron_location/lib/location.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kH","file":"/packages/iron_location.js","sourcesContent":["var Url = Iron.Url;\nvar HASH_PARAM_NAME='__hash__';\n\n/**\n * Given:\n *   http://host:port/some/pathname/?query=string#bar\n *\n * Return:\n *   http://host:port#!some/pathname/?query=string&__hash__=bar\n */\nurlToHashStyle = function (url) {\n  var parts = Url.parse(url);\n  var hash = parts.hash && parts.hash.replace('#', '');\n  var search = parts.search;\n  var pathname = parts.pathname;\n  var root = parts.rootUrl; \n\n  // do we have another hash value that isn't a path?\n  if (hash && hash.charAt(0) !== '!') {\n    var hashQueryString = HASH_PARAM_NAME + '=' + hash;\n    search = search ? (search + '&') : '?';\n    search += hashQueryString;\n    hash = '';\n  }\n\n  // if we don't already have a path on the hash create one\n  if (! hash && pathname) {\n    hash = '#!' + pathname.substring(1);\n  } else if (hash) {\n    hash = '#' + hash;\n  }\n\n  return [\n    root,\n    hash,\n    search\n  ].join('');\n};\n\n/**\n * Given a url that uses the hash style (see above), return a new url that uses\n * the hash path as a normal pathname.\n *\n * Given:\n *   http://host:port#!some/pathname/?query=string&__hash__=bar\n * \n * Return:\n *   http://host:port/some/pathname/?query=string#bar\n */\nurlFromHashStyle = function (url) {\n  var parts = Url.parse(url);\n  var pathname = parts.hash && parts.hash.replace('#!', '/');\n  var search = parts.search;\n  var root = parts.rootUrl;\n  var hash;\n\n  // see if there's a __hash__=value in the query string in which case put it \n  // back in the normal hash position and delete it from the search string.\n  if (_.has(parts.queryObject, HASH_PARAM_NAME)) {\n    hash = '#' + parts.queryObject[HASH_PARAM_NAME];\n    delete parts.queryObject[HASH_PARAM_NAME];\n  } else {\n    hash = '';\n  }\n\n  return [\n    root,\n    pathname,\n    Url.toQueryString(parts.queryObject),\n    hash\n  ].join('');\n};\n\n/**\n * Fix up a pathname intended for use with a hash path by moving any hash\n * fragments into the query string.\n */\nfixHashPath = function (pathname) {\n  var parts = Url.parse(pathname);\n  var query = parts.queryObject;\n  \n  // if there's a hash in the path move that to the query string\n  if (parts.hash) {\n    query[HASH_PARAM_NAME] = parts.hash.replace('#', '')\n  }\n\n  return [\n    '!',\n    parts.pathname.substring(1),\n    Url.toQueryString(query)\n  ].join('');\n};\n","var Url = Iron.Url;\n\nState = function (url, options) {\n  _.extend(this, Url.parse(url), {options: options || {}});\n};\n\n// XXX: should this compare options (e.g. history.state?)\nState.prototype.equals = function (other) {\n  if (!other)\n    return false;\n\n  if (!(other instanceof State))\n    return false;\n\n  if (other.pathname == this.pathname &&\n     other.search == this.search &&\n     other.hash == this.hash &&\n     other.options.historyState === this.options.historyState)\n    return true;\n\n  return false;\n};\n\nState.prototype.isCancelled = function () {\n  return !!this._isCancelled;\n};\n\nState.prototype.cancelUrlChange = function () {\n  this._isCancelled = true;\n};\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Url = Iron.Url;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar current = null;\nvar dep = new Deps.Dependency;\nvar handlers = {go: [], popState: []};\n\nvar isIE9 = function () {\n  return /MSIE 9/.test(navigator.appVersion);\n};\n\nvar isIE8 = function () {\n  return /MSIE 8/.test(navigator.appVersion);\n};\n\nvar usingAppcache = function() {\n  return !! Package.appcache;\n}\n\nvar replaceStateUndefined = function() {\n  return (typeof history === \"undefined\")  || (typeof history.pushState !== \"function\");\n}\n\nvar shouldUseHashPaths = function () {\n  return Location.options.useHashPaths || isIE8() || isIE9() || usingAppcache() || replaceStateUndefined();\n};\n\nvar isUsingHashPaths = function () {\n  return !!Location.options.useHashPaths;\n};\n\nvar runHandlers = function(name, state) {\n  _.each(handlers[name], function(cb) {\n    cb.call(state);\n  });\n}\n\nvar set = function (state) {\n  if (!(state instanceof State))\n    throw new Error(\"Expected a State instance\");\n\n  if (!state.equals(current)) {\n    current = state;\n    dep.changed();\n\n    // return true to indicate state was set to a new value.\n    return true;\n  }\n\n  // state not set\n  return false;\n};\n\nvar setStateFromEventHandler = function () {\n  var href = location.href;\n  var state;\n\n  if (isUsingHashPaths()) {\n    state = new State(urlFromHashStyle(href));\n  } else {\n    state = new State(href, {historyState: history.state});\n  }\n\n  runHandlers('popState', state);\n  set(state);\n};\n\nvar fireOnClick = function (e) {\n  var handler = onClickHandler;\n  handler && handler(e);\n};\n\n/**\n * Go to a url.\n */\nvar go = function (url, options) {\n  options = options || {};\n\n  var state = new State(url, options);\n\n  runHandlers('go', state);\n\n  if (set(state)) {\n    Deps.afterFlush(function () {\n      // if after we've flushed if nobody has cancelled the state then change\n      // the url.\n      if (!state.isCancelled()) {\n        if (isUsingHashPaths()) {\n          location.hash = fixHashPath(url);\n        } else {\n          if (options.replaceState === true)\n            history.replaceState(options.historyState, null, url);\n          else\n            history.pushState(options.historyState, null, url);\n        }\n      }\n    });\n  }\n};\n\nvar onClickHandler = function (e) {\n  try {\n    var el = e.currentTarget;\n    var href = el.href;\n    var path = el.pathname + el.search + el.hash;\n\n    // ie9 omits the leading slash in pathname - so patch up if it's missing\n    path = path.replace(/(^\\/?)/,\"/\");\n\n    // haven't been cancelled already\n    if (e.isDefaultPrevented()) {\n      e.preventDefault();\n      return;\n    }\n\n    // with no meta key pressed\n    if (e.metaKey || e.ctrlKey || e.shiftKey)\n      return;\n\n    // aren't targeting a new window\n    if (el.target)\n      return;\n\n    // aren't external to the app\n    if (!Url.isSameOrigin(href, location.href))\n      return;\n\n    // note that we _do_ handle links which point to the current URL\n    // and links which only change the hash.\n    e.preventDefault();\n\n    // manage setting the new state and maybe pushing onto the pushState stack\n    go(path);\n  } catch (err) {\n    // make sure we can see any errors that are thrown before going to the\n    // server.\n    e.preventDefault();\n    throw err;\n  }\n};\n\n/*****************************************************************************/\n/* Location API */\n/*****************************************************************************/\n\n/**\n * Main Location object. Reactively respond to url changes. Normalized urls\n * between hash style (ie8/9) and normal style using pushState.\n */\nLocation = {};\n\n/**\n * Default options.\n */\nLocation.options = {\n  linkSelector: 'a[href]',\n  useHashPaths: false\n};\n\n/**\n * Set options on the Location object.\n */\nLocation.configure = function (options) {\n  _.extend(this.options, options || {});\n};\n\n/**\n * Reactively get the current state.\n */\nLocation.get = function () {\n  dep.depend();\n  return current;\n};\n\n/**\n * Set the initial state and start listening for url events.\n */\nLocation.start = function () {\n  if (this._isStarted)\n    return;\n\n  var parts = Url.parse(location.href);\n\n  // if we're using the /#/items/5 style then start off at the root url but\n  // store away the pathname, query and hash into the hash fragment so when the\n  // client gets the response we can render the correct page.\n  if (shouldUseHashPaths()) {\n    // if we have any pathname like /items/5 take a trip to the server to get us\n    // back a root url.\n    if (parts.pathname.length > 1) {\n      var url = urlToHashStyle(location.href);\n      window.location = url;\n    }\n\n    // ok good to go\n    this.configure({useHashPaths: true});\n  }\n  // set initial state\n  var href = location.href;\n\n  if (isUsingHashPaths()) {\n    var state = new State(urlFromHashStyle(href));\n    set(state);\n  } else {\n    // if we started at a URL in the /#!items/5 style then we have picked up a\n    // URL from an non-HTML5 user. Let's redirect to /items/5\n    if (parts.hash.replace('#', '')[0] === '!') {\n      var href = urlFromHashStyle(href);\n    }\n    \n    // store the fact that this is the first route we hit.\n    // this serves two purposes\n    //   1. We can tell when we've reached an unhandled route and need to show a\n    //      404 (rather than bailing out to let the server handle it)\n    //   2. Users can look at the state to tell if the history.back() will stay\n    //      inside the app (this is important for mobile apps).\n    var historyState = {initial: true}\n    history.replaceState(historyState, null, href);\n    var state = new State(href, {historyState: historyState});\n    set(state);\n  }\n\n  // bind the event handlers\n  $(window).on('popstate.iron-location', setStateFromEventHandler);\n  $(window).on('hashchange.iron-location', setStateFromEventHandler);\n\n  // make sure we have a document before binding the click handler\n  Meteor.startup(function () {\n    $(document).on('click.iron-location', Location.options.linkSelector, fireOnClick);\n  });\n  \n  this._isStarted = true;\n};\n\n/**\n * Stop the Location from listening for url changes.\n */\nLocation.stop = function () {\n  if (!this._isStarted)\n    return;\n\n  $(window).on('popstate.iron-location');\n  $(window).on('hashchange.iron-location');\n  $(document).off('click.iron-location');\n\n  this._isStarted = false;\n};\n\n/**\n * Assign a different click handler.\n */\nLocation.onClick = function (fn) {\n  onClickHandler = fn;\n};\n\n/**\n * Go to a new url.\n */\nLocation.go = function (url, options) {\n  return go(url, options);\n};\n\n/**\n * Run the supplied callback whenever we \"go\" to a new location.\n *\n * Argument: cb - function, called with no arguments,\n * `this` is the state that's being set, _may_ be modified.\n */\nLocation.onGo = function (cb) {\n  handlers.go.push(cb);\n};\n\n/**\n * Run the supplied callback whenever we \"popState\" to an old location.\n *\n * Argument: cb - function, called with no arguments,\n * `this` is the state that's being set, _may_ be modified.\n */\nLocation.onPopState = function (cb) {\n  handlers.popState.push(cb);\n};\n\n/**\n * Automatically start Iron.Location\n */\nLocation.start();\n\n/*****************************************************************************/\n/* Namespacing */\n/*****************************************************************************/\nIron.Location = Location;\n"]}
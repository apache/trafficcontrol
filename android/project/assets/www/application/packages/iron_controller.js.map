{"version":3,"sources":["meteor://ðŸ’»app/packages/iron_controller/lib/wait_list.js","meteor://ðŸ’»app/packages/iron_controller/lib/controller.js","meteor://ðŸ’»app/packages/iron_controller/lib/controller_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iG;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iG;;;;;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/iron_controller.js","sourcesContent":["/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\n\n/**\n * Returns an object of computation ids starting with\n * the current computation and including all ancestor\n * computations. The data structure is an object\n * so we can index by id and do quick checks.\n */\nvar parentComputations = function () {\n  var list = {};\n  var c = Deps.currentComputation;\n\n  while (c) {\n    list[String(c._id)] = true;\n    c = c._parent;\n  }\n\n  return list;\n};\n\n/**\n * Check whether the user has called ready() and then called wait(). This\n * can cause a condition that can be simplified to this:\n *\n * dep = new Deps.Dependency;\n *\n * Deps.autorun(function () {\n *   dep.depend();\n *   dep.changed();\n * });\n */\nvar assertNoInvalidationLoop = function (dependency) {\n  var parentComps = parentComputations();\n  var depCompIds = _.keys(dependency._dependentsById);\n\n  _.each(depCompIds, function (id) {\n    assert(!parentComps[id], \"\\n\\n\\\nYou called wait() after calling ready() inside the same computation tree.\\\n\\n\\n\\\nYou can fix this problem in two possible ways:\\n\\n\\\n1) Put all of your wait() calls before any ready() calls.\\n\\\n2) Put your ready() call in its own computation with Deps.autorun.\"\n    );\n  });\n};\n\n\n/*****************************************************************************/\n/* WaitList */\n/*****************************************************************************/\n/**\n * A WaitList tracks a list of reactive functions, each in its own computation.\n * The list is ready() when all of the functions return true. This list is not\n * ready (i.e. this.ready() === false) if at least one function returns false.\n *\n * You add functions by calling the wait(fn) method. Each function is run its\n * own computation. The ready() method is a reactive method but only calls the\n * deps changed function if the overall state of the list changes from true to\n * false or from false to true.\n */\nWaitList = function () {\n  this._readyDep = new Deps.Dependency;\n  this._comps = [];\n  this._notReadyCount = 0;\n};\n\n/**\n * Pass a function that returns true or false.\n */\nWaitList.prototype.wait = function (fn) {\n  var self = this;\n\n  var activeComp = Deps.currentComputation;\n\n  assertNoInvalidationLoop(self._readyDep);\n\n  // break with parent computation and grab the new comp\n  Deps.nonreactive(function () {\n\n    // store the cached result so we can see if it's different from one run to\n    // the next.\n    var cachedResult = null;\n\n    // create a computation for this handle\n    var comp = Deps.autorun(function (c) {\n      // let's get the new result coerced into a true or false value.\n      var result = !!fn();\n\n      var oldNotReadyCount = self._notReadyCount;\n\n      // if it's the first run and we're false then inc\n      if (c.firstRun && !result)\n        self._notReadyCount++;\n      else if (cachedResult !== null && result !== cachedResult && result === true)\n        self._notReadyCount--;\n      else if (cachedResult !== null && result !== cachedResult && result === false)\n        self._notReadyCount++;\n\n      cachedResult = result;\n\n      if (oldNotReadyCount === 0 && self._notReadyCount > 0)\n        self._readyDep.changed();\n      else if (oldNotReadyCount > 0 && self._notReadyCount === 0)\n        self._readyDep.changed();\n    });\n\n    self._comps.push(comp);\n\n    if (activeComp) {\n      activeComp.onInvalidate(function () {\n        // keep the old computation and notReadyCount the same for one\n        // flush cycle so that we don't end up in an intermediate state\n        // where list.ready() is not correct.\n\n        // keep the state the same until the flush cycle is complete\n        Deps.afterFlush(function () {\n          // stop the computation\n          comp.stop();\n\n          // remove the computation from the list\n          self._comps.splice(_.indexOf(self._comps, comp), 1);\n\n          if (cachedResult === false) {\n            self._notReadyCount--;\n\n            if (self._notReadyCount === 0)\n              self._readyDep.changed();\n          }\n        });\n      });\n    }\n  });\n};\n\nWaitList.prototype.ready = function () {\n  this._readyDep.depend();\n  return this._notReadyCount === 0;\n};\n\nWaitList.prototype.stop = function () {\n  _.each(this._comps, function (c) { c.stop(); });\n  this._comps = [];\n};\n\nIron.WaitList = WaitList;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar debug = Iron.utils.debug('iron:controller');\nvar Layout = Iron.Layout;\nvar DynamicTemplate = Iron.DynamicTemplate;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar bindData = function (value, thisArg) {\n  return function () {\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;\n  };\n};\n\n/*****************************************************************************/\n/* Controller */\n/*****************************************************************************/\nController = function (options) {\n  var self = this;\n  this.options = options || {};\n  this._layout = this.options.layout || new Layout(this.options);\n  this._isController = true;\n  this._layout._setLookupHost(this);\n\n  // grab the event map from the Controller constructor which was\n  // set if the user does MyController.events({...});\n  var eventMap = Controller._collectEventMaps.call(this.constructor);\n  this._layout.events(eventMap, this);\n\n  this.init(options);\n};\n\n/**\n * Set or get the layout's template and optionally its data context.\n */\nController.prototype.layout = function (template, options) {\n  var self = this;\n\n  this._layout.template(template);\n\n  // check whether options has a data property\n  if (options && (_.has(options, 'data')))\n    this._layout.data(bindData(options.data, this));\n\n  return {\n    data: function (val) {\n      return self._layout.data(bindData(val, self));\n    }\n  };\n};\n\n/**\n * Render a template into a region of the layout.\n */\nController.prototype.render = function (template, options) {\n  var self = this;\n\n  if (options && (typeof options.data !== 'undefined'))\n    options.data = bindData(options.data, this);\n\n  var tmpl = this._layout.render(template, options);\n\n  // allow caller to do: this.render('MyTemplate').data(function () {...});\n  return {\n    data: function (func) {\n      return tmpl.data(bindData(func, self));\n    }\n  };\n};\n\n/**\n * Begin recording rendered regions.\n */\nController.prototype.beginRendering = function (onComplete) {\n  return this._layout.beginRendering(onComplete);\n};\n\n/*****************************************************************************/\n/* Controller Static Methods */\n/*****************************************************************************/\n/**\n * Inherit from Controller.\n *\n * Note: The inheritance function in Meteor._inherits is broken. Static\n * properties on functions don't get copied.\n */\nController.extend = function (props) {\n  return Iron.utils.extend(this, props); \n};\n\nController.events = function (events) {\n  this._eventMap = events;\n  return this;\n};\n\n/**\n * Returns a single event map merged from super to child.\n * Called from the constructor function like this:\n *\n * this.constructor._collectEventMaps()\n */\n\nvar mergeStaticInheritedObjectProperty = function (ctor, prop) {\n  var merge = {};\n\n  if (ctor.__super__)\n    _.extend(merge, mergeStaticInheritedObjectProperty(ctor.__super__.constructor, prop));\n  \n  return _.has(ctor, prop) ? _.extend(merge, ctor[prop]) : merge;\n};\n\nController._collectEventMaps = function () {\n  return mergeStaticInheritedObjectProperty(this, '_eventMap');\n};\n\n// NOTE: helpers are not inherited from one controller to another, for now.\nController._helpers = {};\nController.helpers = function (helpers) {\n  _.extend(this._helpers, helpers);\n  return this;\n};\n\n/*****************************************************************************/\n/* Global Helpers */\n/*****************************************************************************/\nif (typeof Template !== 'undefined') {\n  /**\n   * Returns the nearest controller for a template instance. You can call this\n   * function from inside a template helper.\n   *\n   * Example:\n   * Template.MyPage.helpers({\n   *   greeting: function () {\n   *    var controller = Iron.controller();\n   *    return controller.state.get('greeting');\n   *   }\n   * });\n   */\n  Iron.controller = function () {\n    //XXX establishes a reactive dependency which causes helper to run\n    return DynamicTemplate.findLookupHostWithProperty(Blaze.getView(), '_isController');\n  };\n\n  /**\n   * Find a lookup host with a state key and return it reactively if we have\n   * it.\n   */\n  Template.registerHelper('get', function (key) {\n    var controller = Iron.controller();\n    if (controller && controller.state)\n      return controller.state.get(key);\n  });\n}\n/*****************************************************************************/\n/* Namespacing */\n/*****************************************************************************/\nIron.Controller = Controller;\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Layout = Iron.Layout;\nvar debug = Iron.utils.debug('iron:controller');\nvar defaultValue = Iron.utils.defaultValue;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar bindData = function (value, thisArg) {\n  return function () {\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;\n  };\n};\n\n/*****************************************************************************/\n/* Controller Client */\n/*****************************************************************************/\n/**\n * Client specific init code.\n */\nController.prototype.init = function (options) {\n  this._waitlist = new WaitList;\n  this.state = new ReactiveDict;\n};\n\n/**\n * Insert the controller's layout into the DOM.\n */\nController.prototype.insert = function (options) {\n  return this._layout.insert.apply(this._layout, arguments);\n};\n\n/**\n * Add an item to the waitlist.\n */\nController.prototype.wait = function (fn) {\n  var self = this;\n\n  if (!fn)\n    // it's possible fn is just undefined but we'll just return instead\n    // of throwing an error, to make it easier to call this function\n    // with waitOn which might not return anything.\n    return;\n\n  if (_.isArray(fn)) {\n    _.each(fn, function eachWait (fnOrHandle) {\n      self.wait(fnOrHandle);\n    });\n  } else if (fn.ready) {\n    this._waitlist.wait(function () { return fn.ready(); });\n  } else {\n    this._waitlist.wait(fn);\n  }\n\n  return this;\n};\n\n/**\n * Returns true if all items in the waitlist are ready.\n */\nController.prototype.ready = function () {\n  return this._waitlist.ready();\n};\n\n/**\n * Clean up the controller and stop the waitlist.\n */\nController.prototype.stop = function () {\n  this._waitlist.stop();\n};\n"]}
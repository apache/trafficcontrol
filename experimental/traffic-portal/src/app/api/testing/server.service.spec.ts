/**
 * @license Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { TestBed } from "@angular/core/testing";
import { ResponseServer, ResponseServerCapability, ResponseStatus } from "trafficops-types";

import { ProfileService } from "../profile.service";
import { ServerService as ConcreteServerService } from "../server.service";

import { ServerService } from "./server.service";

import { APITestingModule } from ".";

describe("TestingServerService", () => {
	let service: ServerService;

	beforeEach(async () => {
		TestBed.configureTestingModule({
			imports: [APITestingModule],
			providers: [
				ServerService,
			]
		});
		service = TestBed.inject(ServerService);
	});

	describe("Server-related functionality", () => {
		let server: ResponseServer;

		beforeEach(async () => {
			const profile = (await TestBed.inject(ProfileService).getProfiles())[0];
			server = await service.createServer({
				cachegroupId: 1,
				cdnId: 1,
				domainName: "quest",
				hostName: "test",
				interfaces: [],
				physLocationId: 1,
				profileNames: [profile.name],
				statusId: 1,
				typeId: 1
			});
			expect(server.id).toBeTruthy();
		});

		it("gets multiple servers", async () => {
			const servers = await service.getServers();
			expect(servers.length).toBeGreaterThanOrEqual(1);
			expect(servers).toEqual(service.servers);
		});

		it("gets a single server by ID", async () => {
			await expectAsync(service.getServers(server.id)).toBeResolvedTo(server);
		});

		it("gets a single server by hostName", async () => {
			await expectAsync(service.getServers(server.hostName)).toBeResolvedTo(server);
		});

		it("throws an error when the requested server doesn't exist", async () => {
			await expectAsync(service.getServers(-1)).toBeRejected();
			await expectAsync(service.getServers(String((new Date()).valueOf()))).toBeRejected();
		});

		it("updates existing servers", async () => {
			const modify = {
				...server,
				tcpPort: (server.tcpPort ?? 0) +1
			};
			const initialLength = service.servers.length;
			const updated = await service.updateServer(modify);
			expect(service.servers).toContain(updated);
			expect(service.servers).not.toContain(server);
			expect(service.servers).toHaveSize(initialLength);
		});
		it("throws an error when asked to update a non-existent server", async () => {
			await expectAsync(service.updateServer(-1, {...server})).toBeRejected();
		});
		it("throws an error for invalid call signatures to the server update method", async () => {
			const promise = (service as unknown as {updateServer: (id: number) => Promise<ResponseServer>}).updateServer(server.id);
			await expectAsync(promise).toBeRejected();
		});

		it("deletes Servers", async () => {
			const initialLength = service.servers.length;
			await expectAsync(service.deleteServer(server)).toBeResolvedTo(server);
			expect(service.servers.length).toEqual(initialLength - 1);
			expect(service.servers).not.toContain(server);
		});
		it("throws an error when asked to delete a non-existent server", async () => {
			await expectAsync(service.deleteServer(-1)).toBeRejected();
		});

		it("generates serverchecks", async () => {
			const checks = await service.getServerChecks();
			expect(checks).toHaveSize(service.servers.length);
		});

		it("generates checks for a specific server", async () => {
			const check = await service.getServerChecks(server);
			expect(check.adminState).toBe(server.status);
			expect(check.cacheGroup).toBe(server.cachegroup);
			expect(check.hostName).toBe(server.hostName);
			expect(check.id).toBe(server.id);
			expect(check.profile).toBe(server.profileNames[0]);
			expect(check.revalPending).toBe(server.revalPending);
			expect(check.type).toBe(server.type);
			expect(check.updPending).toBe(server.updPending);

			// server check check data isn't generated by the testing service,
			// because no check extensions are ever registered.
			expect(check.checks).toBeUndefined();
		});

		it("throws an error when asked to generate checks for a non-existent server", async () => {
			await expectAsync(service.getServerChecks(-1)).toBeRejected();
		});

		it("updates a server's status to a new one", async () => {
			const status = server.status === "ONLINE" ? "OFFLINE" : "ONLINE";
			await service.updateServerStatus(server, status, "no good reason");
			expect(server.status).toBe(status);
		});
		it("updates a server's status to a new one using the server's ID", async () => {
			const status = server.status === "ONLINE" ? "OFFLINE" : "ONLINE";
			await service.updateServerStatus(server.id, status);
			expect(server.status).toBe(status);
		});
		it("updates a server's status using a status object", async () => {
			const status = service.statuses.find(s => s.id !== server.statusId);
			if (!status) {
				throw new Error("no statuses exist (besides the one the server already has)");
			}
			await service.updateServerStatus(server, status);
			expect(server.status).toBe(status.name);
			expect(server.statusId).toBe(status.id);
		});
		it("throws an error if asked to update the status of a non-existent server", async () => {
			await expectAsync(service.updateServerStatus(-1, "")).toBeRejected();
		});
		it("throws an error if asked to update the status of server to a non-existent Status", async () => {
			await expectAsync(service.updateServerStatus(server, "")).toBeRejected();
		});
	});

	describe("Status functionality", () => {
		let status: ResponseStatus;

		beforeEach(async () => {
			const statuses = await service.getStatuses();
			if (statuses.length < 2) {
				return fail("not enough statuses for testing");
			}
			status = statuses[1];
			expect(statuses).toHaveSize(service.statuses.length);
		});

		it("gets a single Status by name", async () => {
			await expectAsync(service.getStatuses(status.name)).toBeResolvedTo(status);
		});
		it("gets a single Status by ID", async () => {
			await expectAsync(service.getStatuses(status.id)).toBeResolvedTo(status);
		});
		it("throws an error hen the requested Status doesn't exist", async () => {
			await expectAsync(service.getStatuses(-1)).toBeRejected();
		});

		it("creates new Statuses", async () => {
			const initialLength = service.statuses.length;
			const name = `test-${(new Date()).valueOf()}`;
			const created = await service.createStatus({name});
			expect(service.statuses).toHaveSize(initialLength+1);
			expect(created.name).toBe(name);
			expect(service.statuses).toContain(created);
		});

		it("deletes Statuses", async () => {
			const initialLength = service.statuses.length;
			const deleted = await service.deleteStatus(status);
			expect(service.statuses).not.toContain(status);
			expect(deleted).toBe(status);
			expect(service.statuses).toHaveSize(initialLength-1);
		});
		it("deletes Statuses by ID", async () => {
			const initialLength = service.statuses.length;
			const deleted = await service.deleteStatus(status.id);
			expect(service.statuses).not.toContain(status);
			expect(deleted).toBe(status);
			expect(service.statuses).toHaveSize(initialLength-1);
		});
		it("throws an error when asked to delete a Status that doesn't exist", async () => {
			await expectAsync(service.deleteStatus(-1)).toBeRejected();
		});

		it("updates Statuses", async () => {
			const s = {...status};
			s.name += "quest";
			const updated = await service.updateStatus(s);
			expect(updated.name).toEqual(s.name);
			expect(service.statuses).not.toContain(status);
			expect(service.statuses).toContain(updated);
			expect(updated.id).toEqual(status.id);
		});
		it("throws an error when asked to update a non-existent Status", async () => {
			await expectAsync(service.updateStatus({description: "", id: -1, lastUpdated: new Date(), name: ""})).toBeRejected();
		});
	});

	describe("Capability functionality", () => {
		let cap: ResponseServerCapability;

		beforeEach(async () => {
			const initialLength = service.capabilities.length;
			const name = `test-${(new Date()).valueOf()}`;
			cap = await service.createCapability({name});
			expect(service.capabilities).toHaveSize(initialLength+1);
			expect(cap.name).toBe(name);
			expect(service.capabilities).toContain(cap);
		});

		it("gets a single Capability by name", async () => {
			await expectAsync(service.getCapabilities(cap.name)).toBeResolvedTo(cap);
		});
		it("throws an error hen the requested Capability doesn't exist", async () => {
			await expectAsync(service.getCapabilities(String((new Date()).valueOf()))).toBeRejected();
		});

		it("deletes Capabilities", async () => {
			const initialLength = service.capabilities.length;
			await service.deleteCapability(cap);
			expect(service.capabilities).not.toContain(cap);
			expect(service.capabilities).toHaveSize(initialLength-1);
		});
		it("deletes Capabilities by name", async () => {
			const initialLength = service.capabilities.length;
			await service.deleteCapability(cap.name);
			expect(service.capabilities).not.toContain(cap);
			expect(service.capabilities).toHaveSize(initialLength-1);
		});
		it("throws an error when asked to delete a Capability that doesn't exist", async () => {
			await expectAsync(service.deleteCapability(String((new Date()).valueOf()))).toBeRejected();
		});

		it("updates Capabilities", async () => {
			const c = {...cap};
			c.name += "quest";
			const updated = await service.updateCapability(cap.name, c);
			expect(updated.name).toEqual(c.name);
			expect(service.capabilities).not.toContain(cap);
			expect(service.capabilities).toContain(updated);
		});
		it("throws an error when asked to update a non-existent Capability", async () => {
			const c = {lastUpdated: new Date(), name: "anything"};
			await expectAsync(service.updateCapability(String((new Date()).valueOf()), c)).toBeRejected();
		});
		it("throws an error when a capability is updated to use an existing name", async () => {
			await expectAsync(service.updateCapability(cap.name, cap)).toBeRejected();
		});

		it("throws an error when asked to create a capability with a name already in use", async () => {
			await expectAsync(service.createCapability(cap)).toBeRejected();
		});
	});

	describe("Queueing/Dequeueing functionality", () => {
		let server: ResponseServer;

		beforeEach(async () => {
			const profile = (await TestBed.inject(ProfileService).getProfiles())[0];
			server = await service.createServer({
				cachegroupId: 1,
				cdnId: 1,
				domainName: "quest",
				hostName: "test",
				interfaces: [],
				physLocationId: 1,
				profileNames: [profile.name],
				statusId: 1,
				typeId: 1
			});
			expect(server.id).toBeTruthy();
			expect(server.updPending).toBeFalse();
		});

		it("queues and clears updates", async () => {
			let resp: {action: "queue" | "dequeue"; serverId: number} = await service.queueUpdates(server);
			expect(resp.action).toBe("queue");
			expect(resp.serverId).toBe(server.id);
			expect(server.updPending).toBeTrue();

			resp = await service.clearUpdates(server);
			expect(resp.action).toBe("dequeue");
			expect(resp.serverId).toBe(server.id);
			expect(server.updPending).toBeFalse();
		});

		it("queues and clears updates by server ID", async () => {
			let resp: {action: "queue" | "dequeue"; serverId: number} = await service.queueUpdates(server.id);
			expect(resp.action).toBe("queue");
			expect(resp.serverId).toBe(server.id);
			expect(server.updPending).toBeTrue();

			resp = await service.clearUpdates(server.id);
			expect(resp.action).toBe("dequeue");
			expect(resp.serverId).toBe(server.id);
			expect(server.updPending).toBeFalse();
		});

		it("throws an error when asked to queue or clear updates on a non-existent server", async () => {
			await expectAsync(service.queueUpdates(-1)).toBeRejected();
			await expectAsync(service.clearUpdates(-1)).toBeRejected();
		});
	});

	describe("static methods", () => {
		let server: ResponseServer;

		beforeEach(async () => {
			const profile = (await TestBed.inject(ProfileService).getProfiles())[0];
			server = await service.createServer({
				cachegroupId: 1,
				cdnId: 1,
				domainName: "quest",
				hostName: "test",
				interfaces: [],
				physLocationId: 1,
				profileNames: [profile.name],
				statusId: 1,
				typeId: 1
			});
			expect(server.id).toBeTruthy();
		});

		it("defers to the concrete service for calculating service interfaces", () => {
			const spy = spyOn(ConcreteServerService, "getServiceInterface");
			expect(spy).not.toHaveBeenCalled();
			ServerService.getServiceInterface(server);
			expect(spy).toHaveBeenCalledOnceWith(server);
		});

		it("defers to the concrete service for extracting netmasks", () => {
			const spy = spyOn(ConcreteServerService, "extractNetmask");
			expect(spy).not.toHaveBeenCalled();
			ServerService.extractNetmask("192.0.1.0");
			expect(spy).toHaveBeenCalledOnceWith("192.0.1.0");
		});
	});
});
